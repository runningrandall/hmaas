import { {{pascalCase name}}Repository, {{pascalCase name}} } from "../domain/{{camelCase name}}";
import { PaginationOptions, PaginatedResult } from "../domain/item";
import { DBService } from "../entities/service";
import { z } from "zod";
import { logger } from "../lib/observability";

/**
* Zod schema for validating data coming OUT of DynamoDB.
* Catches data corruption or schema drift at the adapter boundary.
*/
const Dynamo{{pascalCase name}}Schema = z.object({
{{camelCase name}}Id: z.string(),
name: z.string(),
description: z.string().optional().nullable(),
createdAt: z.union([z.string(), z.number()]).transform(v => String(v)),
updatedAt: z.union([z.string(), z.number()]).optional().transform(v => v != null ? String(v) : undefined),
}).passthrough();

function parse{{pascalCase name}}(data: unknown): {{pascalCase name}} {
const result = Dynamo{{pascalCase name}}Schema.safeParse(data);
if (!result.success) {
logger.error("Data validation failed reading from DynamoDB", {
errors: result.error.issues,
data,
});
throw new Error(`Data integrity error: ${result.error.message}`);
}
return result.data as {{pascalCase name}};
}

const DEFAULT_PAGE_SIZE = 20;

export class Dynamo{{pascalCase name}}Repository implements {{pascalCase name}}Repository {
async create(item: {{pascalCase name}}): Promise<{{pascalCase name}}> {
    const { createdAt, ...data } = item;
    const result = await DBService.entities.{{camelCase name}}.create(data).go();
    return parse{{pascalCase name}}(result.data);
    }

    async get({{camelCase name}}Id: string): Promise<{{pascalCase name}} | null> {
        const result = await DBService.entities.{{camelCase name}}.get({ {{camelCase name}}Id }).go();
        if (!result.data) return null;
        return parse{{pascalCase name}}(result.data);
        }

        async list(options?: PaginationOptions): Promise<PaginatedResult<{{pascalCase name}}>> {
            const limit = options?.limit || DEFAULT_PAGE_SIZE;

            const result = await DBService.entities.{{camelCase name}}.scan.go({
            limit,
            ...(options?.cursor && { cursor: options.cursor }),
            });

            return {
            items: result.data.map(parse{{pascalCase name}}),
            cursor: result.cursor ?? null,
            };
            }

            async delete({{camelCase name}}Id: string): Promise<void> {
                await DBService.entities.{{camelCase name}}.delete({ {{camelCase name}}Id }).go();
                }
                }